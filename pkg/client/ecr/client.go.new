package ecr

import (
	"context"
	"fmt"
	"freightliner/pkg/client/common"
	"freightliner/pkg/helper/errors"
	"freightliner/pkg/helper/log"
	"net/http"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials/stscreds"
	awsecr "github.com/aws/aws-sdk-go-v2/service/ecr"
	ecrtypes "github.com/aws/aws-sdk-go-v2/service/ecr/types"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	awsauth "github.com/awslabs/amazon-ecr-credential-helper/ecr-login"
	"github.com/google/go-containerregistry/pkg/name"
	"github.com/google/go-containerregistry/pkg/v1/remote"
	"github.com/google/go-containerregistry/pkg/v1/remote/transport"
)

// ECRAPI interface for AWS ECR operations
type ECRAPI interface {
	ListImages(ctx context.Context, params *awsecr.ListImagesInput, optFns ...func(*awsecr.Options)) (*awsecr.ListImagesOutput, error)
	BatchGetImage(ctx context.Context, params *awsecr.BatchGetImageInput, optFns ...func(*awsecr.Options)) (*awsecr.BatchGetImageOutput, error)
	PutImage(ctx context.Context, params *awsecr.PutImageInput, optFns ...func(*awsecr.Options)) (*awsecr.PutImageOutput, error)
	BatchDeleteImage(ctx context.Context, params *awsecr.BatchDeleteImageInput, optFns ...func(*awsecr.Options)) (*awsecr.BatchDeleteImageOutput, error)
	DescribeImages(ctx context.Context, params *awsecr.DescribeImagesInput, optFns ...func(*awsecr.Options)) (*awsecr.DescribeImagesOutput, error)
	DescribeRepositories(ctx context.Context, params *awsecr.DescribeRepositoriesInput, optFns ...func(*awsecr.Options)) (*awsecr.DescribeRepositoriesOutput, error)
	CreateRepository(ctx context.Context, params *awsecr.CreateRepositoryInput, optFns ...func(*awsecr.Options)) (*awsecr.CreateRepositoryOutput, error)
	GetAuthorizationToken(ctx context.Context, params *awsecr.GetAuthorizationTokenInput, optFns ...func(*awsecr.Options)) (*awsecr.GetAuthorizationTokenOutput, error)
}

// Client implements the registry client interface for AWS ECR
type Client struct {
	common.BaseClient
	ecr       ECRAPI
	region    string
	accountID string
}

// ClientOptions provides configuration for connecting to ECR
type ClientOptions struct {
	// Region is the AWS region for ECR
	Region string

	// AccountID is the AWS account ID (optional, uses default credentials if empty)
	AccountID string

	// Profile is the AWS profile to use (optional)
	Profile string

	// RoleARN is an optional IAM role to assume for ECR operations
	RoleARN string

	// CredentialsFile is the path to AWS credentials file (optional)
	CredentialsFile string

	// Logger is the logger to use
	Logger *log.Logger
}

// NewClient creates a new ECR client
func NewClient(opts ClientOptions) (*Client, error) {
	if opts.Region == "" {
		return nil, errors.InvalidInputf("AWS region is required")
	}

	if opts.Logger == nil {
		opts.Logger = log.NewLogger(log.InfoLevel)
	}

	// Load AWS config
	var configOpts []func(*config.LoadOptions) error
	configOpts = append(configOpts, config.WithRegion(opts.Region))

	// Use profile if specified
	if opts.Profile != "" {
		configOpts = append(configOpts, config.WithSharedConfigProfile(opts.Profile))
	}

	cfg, err := config.LoadDefaultConfig(context.Background(), configOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "failed to load AWS config")
	}

	var ecrClient *awsecr.Client

	// If a role ARN is provided, assume the role and create an ECR client with the assumed role credentials
	if opts.RoleARN != "" {
		// Create an STS client to assume the role
		stsClient := sts.NewFromConfig(cfg)
		provider := stscreds.NewAssumeRoleProvider(stsClient, opts.RoleARN)

		// Create a new config with the role credentials
		roleCfg := aws.Config{
			Credentials: aws.NewCredentialsCache(provider),
			Region:      cfg.Region,
		}

		// Create an ECR client with the assumed role credentials
		ecrClient = awsecr.NewFromConfig(roleCfg)
	} else {
		// Use default credentials
		ecrClient = awsecr.NewFromConfig(cfg)
	}

	// Create authenticator for ECR
	authenticator := NewECRAuthenticator(ecrClient, opts.Region)

	// Generate registry hostname
	accountID := opts.AccountID
	if accountID == "" {
		// If account ID not provided, get it from the AWS identity
		stsClient := sts.NewFromConfig(cfg)
		identity, err := stsClient.GetCallerIdentity(context.Background(), &sts.GetCallerIdentityInput{})
		if err != nil {
			return nil, errors.Wrap(err, "failed to get AWS account ID")
		}
		accountID = *identity.Account
	}

	registry := fmt.Sprintf("%s.dkr.ecr.%s.amazonaws.com", accountID, opts.Region)

	// Create base client
	baseClient := common.NewBaseClient(common.ClientOptions{
		Logger:   opts.Logger,
		Registry: registry,
		Region:   opts.Region,
	})

	// Set authenticator
	baseClient.SetAuthenticator(authenticator)

	// Create client
	client := &Client{
		BaseClient: *baseClient,
		ecr:        ecrClient,
		region:     opts.Region,
		accountID:  accountID,
	}

	return client, nil
}

// GetRegistryName returns the ECR registry endpoint
func (c *Client) GetRegistryName() string {
	return c.Registry
}

// ListRepositories lists all repositories in the registry
func (c *Client) ListRepositories(ctx context.Context, prefix string) ([]string, error) {
	if ctx.Err() != nil {
		return nil, ctx.Err()
	}

	c.Logger.Debug("Listing ECR repositories", map[string]interface{}{
		"registry": c.Registry,
		"prefix":   prefix,
	})

	var repositories []string
	var nextToken *string

	for {
		input := &awsecr.DescribeRepositoriesInput{
			NextToken: nextToken,
		}

		// Apply account ID if specified
		if c.accountID != "" {
			input.RegistryId = &c.accountID
		}

		// Call the ECR API
		resp, err := c.ecr.DescribeRepositories(ctx, input)
		if err != nil {
			return nil, errors.Wrap(err, "failed to list ECR repositories")
		}

		// Process the response
		for _, repo := range resp.Repositories {
			repoName := *repo.RepositoryName
			if prefix == "" || strings.HasPrefix(repoName, prefix) {
				repositories = append(repositories, repoName)
			}
		}

		// Continue pagination if more results
		nextToken = resp.NextToken
		if nextToken == nil {
			break
		}
	}

	c.Logger.Info("Listed ECR repositories", map[string]interface{}{
		"count":  len(repositories),
		"prefix": prefix,
	})

	return repositories, nil
}

// GetRepository returns a repository by name
func (c *Client) GetRepository(ctx context.Context, repoName string) (common.Repository, error) {
	if ctx.Err() != nil {
		return nil, ctx.Err()
	}

	if repoName == "" {
		return nil, errors.InvalidInputf("repository name cannot be empty")
	}

	c.Logger.Debug("Getting ECR repository", map[string]interface{}{
		"registry":   c.Registry,
		"repository": repoName,
	})

	// First check if repository exists
	input := &awsecr.DescribeRepositoriesInput{
		RepositoryNames: []string{repoName},
	}

	if c.accountID != "" {
		input.RegistryId = &c.accountID
	}

	// Call the ECR API
	_, err := c.ecr.DescribeRepositories(ctx, input)
	if err != nil {
		// If the repository does not exist, return error
		var repoNotFoundException *ecrtypes.RepositoryNotFoundException
		if errors.As(err, &repoNotFoundException) {
			return nil, errors.NotFoundf("ECR repository not found: %s", repoName)
		}
		return nil, errors.Wrap(err, "failed to get ECR repository")
	}

	// Create a proper repository reference
	repository, err := name.NewRepository(fmt.Sprintf("%s/%s", c.Registry, repoName))
	if err != nil {
		return nil, errors.Wrap(err, "failed to create repository reference")
	}

	// Create repository instance
	return NewRepository(c, repoName, repository), nil
}

// CreateRepository creates a new repository in ECR
func (c *Client) CreateRepository(ctx context.Context, repoName string, tags map[string]string) (common.Repository, error) {
	if ctx.Err() != nil {
		return nil, ctx.Err()
	}

	if repoName == "" {
		return nil, errors.InvalidInputf("repository name cannot be empty")
	}

	c.Logger.Debug("Creating ECR repository", map[string]interface{}{
		"registry":   c.Registry,
		"repository": repoName,
	})

	// Convert tags to ECR tag format
	var ecrTags []ecrtypes.Tag
	for k, v := range tags {
		key, value := k, v
		ecrTags = append(ecrTags, ecrtypes.Tag{
			Key:   &key,
			Value: &value,
		})
	}

	// Call the ECR API to create the repository
	input := &awsecr.CreateRepositoryInput{
		RepositoryName: aws.String(repoName),
		Tags:           ecrTags,
	}

	if c.accountID != "" {
		input.RegistryId = aws.String(c.accountID)
	}

	resp, err := c.ecr.CreateRepository(ctx, input)
	if err != nil {
		// Handle case where repository already exists
		var alreadyExistsException *ecrtypes.RepositoryAlreadyExistsException
		if errors.As(err, &alreadyExistsException) {
			c.Logger.Info("ECR repository already exists", map[string]interface{}{
				"repository": repoName,
			})
			return c.GetRepository(ctx, repoName)
		}
		return nil, errors.Wrap(err, "failed to create ECR repository")
	}

	// Create a proper repository reference
	repository, err := name.NewRepository(fmt.Sprintf("%s/%s", c.Registry, repoName))
	if err != nil {
		return nil, errors.Wrap(err, "failed to create repository reference")
	}

	c.Logger.Info("Created ECR repository", map[string]interface{}{
		"repository": repoName,
		"registry":   c.Registry,
		"arn":        *resp.Repository.RepositoryArn,
	})

	// Create repository instance
	return NewRepository(c, repoName, repository), nil
}

// GetTransport returns an authenticated HTTP transport for ECR
func (c *Client) GetTransport(repositoryName string) (http.RoundTripper, error) {
	return c.CreateTransport(context.Background(), repositoryName)
}

// GetDefaultCredentialHelper returns the default credential helper for ECR
func GetDefaultCredentialHelper() *awsauth.ECRHelper {
	return &awsauth.ECRHelper{}
}
