package vulnerability

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/google/go-containerregistry/pkg/name"
)

// GrypeScanner wraps the Grype CLI for vulnerability scanning
type GrypeScanner struct {
	grypePath string
	dbPath    string
	timeout   time.Duration
}

// NewGrypeScanner creates a new Grype-based scanner
func NewGrypeScanner(dbPath string) (*GrypeScanner, error) {
	// Check if grype is installed
	grypePath, err := exec.LookPath("grype")
	if err != nil {
		return nil, fmt.Errorf("grype not found in PATH: %w", err)
	}

	// Use default DB path if not specified
	if dbPath == "" {
		homeDir, err := os.UserHomeDir()
		if err == nil {
			dbPath = filepath.Join(homeDir, ".cache", "grype", "db")
		}
	}

	return &GrypeScanner{
		grypePath: grypePath,
		dbPath:    dbPath,
		timeout:   10 * time.Minute,
	}, nil
}

// GrypeConfig configures Grype execution
type GrypeConfig struct {
	// Fail on severity level
	FailOn Severity

	// Only show fixed vulnerabilities
	OnlyFixed bool

	// Ignore unfixed vulnerabilities
	IgnoreUnfixed bool

	// Output format
	OutputFormat string // json, table, cyclonedx, sarif, template

	// Scope: all-layers, squashed
	Scope string

	// Platform
	Platform string

	// Exclude patterns
	Exclude []string

	// Registry authentication
	RegistryUser     string
	RegistryPassword string
	RegistryToken    string

	// Database update
	DBUpdateCheck bool

	// Timeout
	Timeout time.Duration
}

// ScanWithGrype scans an image using the Grype CLI
func (gs *GrypeScanner) ScanWithGrype(ctx context.Context, ref name.Reference, config GrypeConfig) (*Report, error) {
	// Update database if requested
	if config.DBUpdateCheck {
		if err := gs.UpdateDatabase(ctx); err != nil {
			// Log warning but continue
			fmt.Printf("Warning: failed to update Grype database: %v\n", err)
		}
	}

	// Build grype command
	args := gs.buildGrypeArgs(ref, config)

	// Create command with timeout
	timeout := config.Timeout
	if timeout == 0 {
		timeout = gs.timeout
	}

	cmdCtx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	cmd := exec.CommandContext(cmdCtx, gs.grypePath, args...)

	// Set environment variables for registry auth
	env := os.Environ()
	if config.RegistryUser != "" && config.RegistryPassword != "" {
		env = append(env,
			fmt.Sprintf("GRYPE_REGISTRY_AUTH_USERNAME=%s", config.RegistryUser),
			fmt.Sprintf("GRYPE_REGISTRY_AUTH_PASSWORD=%s", config.RegistryPassword),
		)
	} else if config.RegistryToken != "" {
		env = append(env,
			fmt.Sprintf("GRYPE_REGISTRY_AUTH_TOKEN=%s", config.RegistryToken),
		)
	}
	cmd.Env = env

	// Capture output
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// Execute grype
	err := cmd.Run()

	// Grype exits with non-zero on vulnerabilities found, so check stderr for actual errors
	if err != nil && stderr.Len() > 0 {
		return nil, fmt.Errorf("grype execution failed: %w, stderr: %s", err, stderr.String())
	}

	// Parse grype output
	report, err := gs.parseGrypeOutput(stdout.Bytes(), ref.String())
	if err != nil {
		return nil, fmt.Errorf("failed to parse grype output: %w", err)
	}

	return report, nil
}

// buildGrypeArgs builds command line arguments for grype
func (gs *GrypeScanner) buildGrypeArgs(ref name.Reference, config GrypeConfig) []string {
	args := []string{ref.String()}

	// Output format (default to JSON for parsing)
	format := config.OutputFormat
	if format == "" {
		format = "json"
	}
	args = append(args, "-o", format)

	// Fail on severity
	if config.FailOn != "" {
		args = append(args, "--fail-on", string(config.FailOn))
	}

	// Only fixed
	if config.OnlyFixed {
		args = append(args, "--only-fixed")
	}

	// Scope
	if config.Scope != "" {
		args = append(args, "--scope", config.Scope)
	}

	// Platform
	if config.Platform != "" {
		args = append(args, "--platform", config.Platform)
	}

	// Exclude patterns
	for _, pattern := range config.Exclude {
		args = append(args, "--exclude", pattern)
	}

	return args
}

// parseGrypeOutput parses Grype JSON output
func (gs *GrypeScanner) parseGrypeOutput(data []byte, imageRef string) (*Report, error) {
	var grypeOutput struct {
		Matches []struct {
			Vulnerability struct {
				ID          string   `json:"id"`
				Severity    string   `json:"severity"`
				Description string   `json:"description"`
				URLs        []string `json:"urls"`
				CVSS        []struct {
					Version string `json:"version"`
					Vector  string `json:"vector"`
					Metrics struct {
						BaseScore           float64 `json:"baseScore"`
						ExploitabilityScore float64 `json:"exploitabilityScore"`
						ImpactScore         float64 `json:"impactScore"`
					} `json:"metrics"`
				} `json:"cvss"`
				Fix struct {
					Versions []string `json:"versions"`
					State    string   `json:"state"`
				} `json:"fix"`
				PublishedDate string `json:"publishedDate"`
				ModifiedDate  string `json:"modifiedDate"`
			} `json:"vulnerability"`
			RelatedVulnerabilities []struct {
				ID         string `json:"id"`
				DataSource string `json:"dataSource"`
			} `json:"relatedVulnerabilities"`
			MatchDetails []struct {
				Type       string            `json:"type"`
				Matcher    string            `json:"matcher"`
				SearchedBy map[string]string `json:"searchedBy"`
				Found      map[string]string `json:"found"`
			} `json:"matchDetails"`
			Artifact struct {
				Name      string `json:"name"`
				Version   string `json:"version"`
				Type      string `json:"type"`
				Locations []struct {
					Path    string `json:"path"`
					LayerID string `json:"layerID"`
				} `json:"locations"`
				Language string `json:"language"`
				PURL     string `json:"purl"`
				CPE      string `json:"cpe"`
			} `json:"artifact"`
		} `json:"matches"`
		Source struct {
			Type   string `json:"type"`
			Target string `json:"target"`
		} `json:"source"`
		Distro struct {
			Name    string `json:"name"`
			Version string `json:"version"`
			IDLike  string `json:"idLike"`
		} `json:"distro"`
		Descriptor struct {
			Name    string `json:"name"`
			Version string `json:"version"`
			DB      struct {
				Built time.Time `json:"built"`
			} `json:"db"`
		} `json:"descriptor"`
	}

	if err := json.Unmarshal(data, &grypeOutput); err != nil {
		return nil, fmt.Errorf("failed to unmarshal grype output: %w", err)
	}

	// Convert to our report structure
	report := &Report{
		ImageRef:        imageRef,
		ScanTime:        time.Now(),
		ScannerName:     fmt.Sprintf("%s-%s", grypeOutput.Descriptor.Name, grypeOutput.Descriptor.Version),
		Vulnerabilities: []Vulnerability{},
	}

	// Convert matches to vulnerabilities
	for _, match := range grypeOutput.Matches {
		vuln := Vulnerability{
			ID:             match.Vulnerability.ID,
			Severity:       gs.convertSeverity(match.Vulnerability.Severity),
			Package:        match.Artifact.Name,
			PackageVersion: match.Artifact.Version,
			PackageType:    match.Artifact.Type,
			Title:          match.Vulnerability.ID,
			Description:    match.Vulnerability.Description,
			URLs:           match.Vulnerability.URLs,
			DataSource:     "grype",
			Metadata:       make(map[string]string),
		}

		// Add fix information
		if len(match.Vulnerability.Fix.Versions) > 0 {
			vuln.FixAvailable = true
			vuln.FixedInVersion = match.Vulnerability.Fix.Versions[0]
			vuln.FixedVersions = match.Vulnerability.Fix.Versions
		}

		// Add CVSS information
		if len(match.Vulnerability.CVSS) > 0 {
			cvss := match.Vulnerability.CVSS[0]
			vuln.CVSSScore = cvss.Metrics.BaseScore
			vuln.CVSSVector = cvss.Vector
			vuln.CVSSMetrics = map[string]float64{
				"base":           cvss.Metrics.BaseScore,
				"exploitability": cvss.Metrics.ExploitabilityScore,
				"impact":         cvss.Metrics.ImpactScore,
			}
		}

		// Parse dates
		if match.Vulnerability.PublishedDate != "" {
			if t, err := time.Parse(time.RFC3339, match.Vulnerability.PublishedDate); err == nil {
				vuln.PublishedDate = t
			}
		}
		if match.Vulnerability.ModifiedDate != "" {
			if t, err := time.Parse(time.RFC3339, match.Vulnerability.ModifiedDate); err == nil {
				vuln.ModifiedDate = t
			}
		}

		// Add metadata
		vuln.Metadata["language"] = match.Artifact.Language
		vuln.Metadata["purl"] = match.Artifact.PURL
		vuln.Metadata["cpe"] = match.Artifact.CPE

		report.Vulnerabilities = append(report.Vulnerabilities, vuln)
	}

	// Calculate summary
	report.Summary = calculateVulnerabilitySummary(report.Vulnerabilities)

	return report, nil
}

// convertSeverity converts Grype severity to our format
func (gs *GrypeScanner) convertSeverity(severity string) Severity {
	switch strings.ToLower(severity) {
	case "critical":
		return SeverityCritical
	case "high":
		return SeverityHigh
	case "medium":
		return SeverityMedium
	case "low":
		return SeverityLow
	case "negligible":
		return SeverityNegligible
	default:
		return SeverityUnknown
	}
}

// calculateVulnerabilitySummary calculates summary statistics
func calculateVulnerabilitySummary(vulns []Vulnerability) Summary {
	summary := Summary{
		TotalVulnerabilities: len(vulns),
	}

	packages := make(map[string]bool)
	packagesWithFixes := make(map[string]bool)
	packagesWithoutFixes := make(map[string]bool)

	for _, vuln := range vulns {
		packages[vuln.Package] = true

		switch vuln.Severity {
		case SeverityCritical:
			summary.Critical++
		case SeverityHigh:
			summary.High++
		case SeverityMedium:
			summary.Medium++
		case SeverityLow:
			summary.Low++
		case SeverityNegligible:
			summary.Negligible++
		default:
			summary.Unknown++
		}

		if vuln.FixAvailable {
			packagesWithFixes[vuln.Package] = true
		} else {
			packagesWithoutFixes[vuln.Package] = true
		}
	}

	summary.TotalPackages = len(packages)
	summary.VulnerablePackages = len(packages)
	summary.PackagesWithFixes = len(packagesWithFixes)
	summary.PackagesWithoutFixes = len(packagesWithoutFixes)

	return summary
}

// UpdateDatabase updates the Grype vulnerability database
func (gs *GrypeScanner) UpdateDatabase(ctx context.Context) error {
	cmd := exec.CommandContext(ctx, gs.grypePath, "db", "update")

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to update database: %w, stderr: %s", err, stderr.String())
	}

	return nil
}

// GetDatabaseStatus returns the status of the vulnerability database
func (gs *GrypeScanner) GetDatabaseStatus(ctx context.Context) (map[string]interface{}, error) {
	cmd := exec.CommandContext(ctx, gs.grypePath, "db", "status", "-o", "json")

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to get database status: %w, stderr: %s", err, stderr.String())
	}

	var status map[string]interface{}
	if err := json.Unmarshal(stdout.Bytes(), &status); err != nil {
		return nil, fmt.Errorf("failed to parse database status: %w", err)
	}

	return status, nil
}

// IsGrypeInstalled checks if Grype is available
func IsGrypeInstalled() bool {
	_, err := exec.LookPath("grype")
	return err == nil
}

// GetGrypeVersion returns the installed Grype version
func GetGrypeVersion() (string, error) {
	cmd := exec.Command("grype", "version")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("failed to get grype version: %w", err)
	}

	// Parse version from output
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, "Version:") || strings.Contains(line, "version:") {
			parts := strings.Split(line, ":")
			if len(parts) >= 2 {
				return strings.TrimSpace(parts[1]), nil
			}
		}
	}

	return strings.TrimSpace(string(output)), nil
}

// InstallGrype provides instructions for installing Grype
func InstallGrype() string {
	return `
Grype is not installed. To install Grype, use one of the following methods:

# macOS (Homebrew)
brew install grype

# Linux (curl)
curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

# Docker
docker pull anchore/grype:latest

For more information, visit: https://github.com/anchore/grype
`
}

// VulnerabilityDB represents a vulnerability database
type VulnerabilityDB struct {
	path string
}

// NewVulnerabilityDB creates a new vulnerability database instance
func NewVulnerabilityDB(path string) (*VulnerabilityDB, error) {
	if path == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return nil, err
		}
		path = filepath.Join(homeDir, ".cache", "freightliner", "vulnerability-db")
	}

	// Ensure directory exists
	if err := os.MkdirAll(path, 0755); err != nil {
		return nil, fmt.Errorf("failed to create database directory: %w", err)
	}

	return &VulnerabilityDB{
		path: path,
	}, nil
}

// Update updates the vulnerability database
func (db *VulnerabilityDB) Update(ctx context.Context) error {
	// In a real implementation, this would download and update the database
	// For now, this is a placeholder that delegates to Grype
	scanner, err := NewGrypeScanner(db.path)
	if err != nil {
		return err
	}

	return scanner.UpdateDatabase(ctx)
}

// QueryPackage queries for vulnerabilities affecting a package
func (db *VulnerabilityDB) QueryPackage(ctx context.Context, name, version, pkgType string) ([]Vulnerability, error) {
	// Placeholder implementation
	// In a real implementation, this would query the local database
	return []Vulnerability{}, nil
}
