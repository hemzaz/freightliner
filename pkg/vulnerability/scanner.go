package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"strings"
	"time"

	"freightliner/pkg/sbom"

	"github.com/google/go-containerregistry/pkg/name"
)

// Severity represents vulnerability severity levels
type Severity string

const (
	SeverityCritical   Severity = "critical"
	SeverityHigh       Severity = "high"
	SeverityMedium     Severity = "medium"
	SeverityLow        Severity = "low"
	SeverityNegligible Severity = "negligible"
	SeverityUnknown    Severity = "unknown"
)

// SeverityScore returns a numeric score for severity (higher is more severe)
func (s Severity) Score() int {
	switch s {
	case SeverityCritical:
		return 5
	case SeverityHigh:
		return 4
	case SeverityMedium:
		return 3
	case SeverityLow:
		return 2
	case SeverityNegligible:
		return 1
	default:
		return 0
	}
}

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	// Vulnerability ID (CVE, GHSA, etc.)
	ID string `json:"id"`

	// Severity level
	Severity Severity `json:"severity"`

	// Package information
	Package        string `json:"package"`
	PackageVersion string `json:"package_version"`
	PackageType    string `json:"package_type"`

	// Fix information
	FixedInVersion string   `json:"fixed_in_version,omitempty"`
	FixAvailable   bool     `json:"fix_available"`
	FixedVersions  []string `json:"fixed_versions,omitempty"`

	// Vulnerability details
	Title       string   `json:"title"`
	Description string   `json:"description"`
	URLs        []string `json:"urls,omitempty"`

	// CVSS scores
	CVSSScore   float64            `json:"cvss_score,omitempty"`
	CVSSVector  string             `json:"cvss_vector,omitempty"`
	CVSSMetrics map[string]float64 `json:"cvss_metrics,omitempty"`

	// Metadata
	PublishedDate time.Time         `json:"published_date,omitempty"`
	ModifiedDate  time.Time         `json:"modified_date,omitempty"`
	DataSource    string            `json:"data_source"`
	Metadata      map[string]string `json:"metadata,omitempty"`
}

// Report represents a vulnerability scan report
type Report struct {
	// Image information
	ImageRef    string    `json:"image_ref"`
	ScanTime    time.Time `json:"scan_time"`
	ScannerName string    `json:"scanner_name"`

	// Vulnerabilities found
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`

	// Summary statistics
	Summary Summary `json:"summary"`

	// SBOM reference
	SBOMRef string `json:"sbom_ref,omitempty"`

	// Policy evaluation
	PolicyResult *PolicyResult `json:"policy_result,omitempty"`
}

// Summary provides statistics about vulnerabilities
type Summary struct {
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	Critical             int `json:"critical"`
	High                 int `json:"high"`
	Medium               int `json:"medium"`
	Low                  int `json:"low"`
	Negligible           int `json:"negligible"`
	Unknown              int `json:"unknown"`

	TotalPackages        int `json:"total_packages"`
	VulnerablePackages   int `json:"vulnerable_packages"`
	PackagesWithFixes    int `json:"packages_with_fixes"`
	PackagesWithoutFixes int `json:"packages_without_fixes"`
}

// Scanner scans container images for vulnerabilities
type Scanner struct {
	config ScanConfig
	db     *VulnerabilityDB
}

// ScanConfig configures vulnerability scanning
type ScanConfig struct {
	// Database configuration
	DBPath       string
	DBUpdateURL  string
	AutoUpdateDB bool

	// Scan options
	FailOnSeverity Severity
	IgnoreUnfixed  bool
	OnlyFixed      bool
	Platform       string

	// Policy configuration
	PolicyPath string
	Policy     *ScanPolicy

	// Output options
	OutputFormat string
	Verbose      bool
}

// ScanPolicy defines vulnerability acceptance policies
type ScanPolicy struct {
	// Maximum allowed vulnerabilities by severity
	MaxCritical int `json:"max_critical"`
	MaxHigh     int `json:"max_high"`
	MaxMedium   int `json:"max_medium"`

	// Ignore specific CVEs
	IgnoreCVEs []string `json:"ignore_cves"`

	// Ignore vulnerabilities in specific packages
	IgnorePackages []string `json:"ignore_packages"`

	// Require fixes to be available
	RequireFixAvailable bool `json:"require_fix_available"`

	// Custom rules
	CustomRules []PolicyRule `json:"custom_rules"`
}

// PolicyRule represents a custom policy rule
type PolicyRule struct {
	Name        string   `json:"name"`
	Severity    Severity `json:"severity"`
	Action      string   `json:"action"` // allow, deny, warn
	Conditions  []string `json:"conditions"`
	Description string   `json:"description"`
}

// PolicyResult represents policy evaluation results
type PolicyResult struct {
	Passed       bool     `json:"passed"`
	FailureCount int      `json:"failure_count"`
	Violations   []string `json:"violations"`
	Warnings     []string `json:"warnings"`
}

// NewScanner creates a new vulnerability scanner
func NewScanner(config ScanConfig) (*Scanner, error) {
	// Initialize vulnerability database
	db, err := NewVulnerabilityDB(config.DBPath)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize vulnerability database: %w", err)
	}

	// Auto-update database if configured
	if config.AutoUpdateDB {
		if err := db.Update(context.Background()); err != nil {
			return nil, fmt.Errorf("failed to update vulnerability database: %w", err)
		}
	}

	return &Scanner{
		config: config,
		db:     db,
	}, nil
}

// Scan scans a container image for vulnerabilities
func (s *Scanner) Scan(ctx context.Context, ref name.Reference) (*Report, error) {
	// Generate SBOM first
	sbomGen := sbom.NewGenerator(sbom.GeneratorConfig{
		Format:                  sbom.FormatSyftJSON,
		IncludeOSPackages:       true,
		IncludeLanguagePackages: true,
	})

	imageSBOM, err := sbomGen.Generate(ctx, ref)
	if err != nil {
		return nil, fmt.Errorf("failed to generate SBOM: %w", err)
	}

	// Scan packages for vulnerabilities
	report := &Report{
		ImageRef:        ref.String(),
		ScanTime:        time.Now(),
		ScannerName:     "freightliner-scanner",
		Vulnerabilities: []Vulnerability{},
		Summary:         Summary{},
	}

	// Track vulnerable packages
	vulnerablePackages := make(map[string]bool)

	// Scan each package
	for _, pkg := range imageSBOM.Packages {
		vulns, err := s.scanPackage(ctx, pkg)
		if err != nil {
			// Log error but continue scanning
			continue
		}

		if len(vulns) > 0 {
			vulnerablePackages[pkg.Name] = true
			report.Vulnerabilities = append(report.Vulnerabilities, vulns...)
		}
	}

	// Calculate summary
	report.Summary = s.calculateSummary(report.Vulnerabilities, len(imageSBOM.Packages), len(vulnerablePackages))

	// Apply policy if configured
	if s.config.Policy != nil {
		report.PolicyResult = s.evaluatePolicy(report)
	}

	// Sort vulnerabilities by severity
	s.sortVulnerabilities(report.Vulnerabilities)

	return report, nil
}

// scanPackage scans a single package for vulnerabilities
func (s *Scanner) scanPackage(ctx context.Context, pkg sbom.Package) ([]Vulnerability, error) {
	// Query vulnerability database
	vulns, err := s.db.QueryPackage(ctx, pkg.Name, pkg.Version, pkg.Type)
	if err != nil {
		return nil, err
	}

	// Filter vulnerabilities based on scan config
	filtered := []Vulnerability{}
	for _, vuln := range vulns {
		// Skip if ignoring unfixed vulnerabilities
		if s.config.IgnoreUnfixed && !vuln.FixAvailable {
			continue
		}

		// Skip if only showing fixed vulnerabilities
		if s.config.OnlyFixed && !vuln.FixAvailable {
			continue
		}

		filtered = append(filtered, vuln)
	}

	return filtered, nil
}

// calculateSummary calculates vulnerability statistics
func (s *Scanner) calculateSummary(vulns []Vulnerability, totalPkgs, vulnerablePkgs int) Summary {
	summary := Summary{
		TotalVulnerabilities: len(vulns),
		TotalPackages:        totalPkgs,
		VulnerablePackages:   vulnerablePkgs,
	}

	packagesWithFixes := make(map[string]bool)
	packagesWithoutFixes := make(map[string]bool)

	for _, vuln := range vulns {
		switch vuln.Severity {
		case SeverityCritical:
			summary.Critical++
		case SeverityHigh:
			summary.High++
		case SeverityMedium:
			summary.Medium++
		case SeverityLow:
			summary.Low++
		case SeverityNegligible:
			summary.Negligible++
		default:
			summary.Unknown++
		}

		if vuln.FixAvailable {
			packagesWithFixes[vuln.Package] = true
		} else {
			packagesWithoutFixes[vuln.Package] = true
		}
	}

	summary.PackagesWithFixes = len(packagesWithFixes)
	summary.PackagesWithoutFixes = len(packagesWithoutFixes)

	return summary
}

// evaluatePolicy evaluates scan results against policy
func (s *Scanner) evaluatePolicy(report *Report) *PolicyResult {
	result := &PolicyResult{
		Passed:     true,
		Violations: []string{},
		Warnings:   []string{},
	}

	policy := s.config.Policy

	// Check severity thresholds
	if policy.MaxCritical >= 0 && report.Summary.Critical > policy.MaxCritical {
		result.Passed = false
		result.Violations = append(result.Violations,
			fmt.Sprintf("Critical vulnerabilities (%d) exceed maximum allowed (%d)",
				report.Summary.Critical, policy.MaxCritical))
		result.FailureCount++
	}

	if policy.MaxHigh >= 0 && report.Summary.High > policy.MaxHigh {
		result.Passed = false
		result.Violations = append(result.Violations,
			fmt.Sprintf("High vulnerabilities (%d) exceed maximum allowed (%d)",
				report.Summary.High, policy.MaxHigh))
		result.FailureCount++
	}

	if policy.MaxMedium >= 0 && report.Summary.Medium > policy.MaxMedium {
		result.Passed = false
		result.Violations = append(result.Violations,
			fmt.Sprintf("Medium vulnerabilities (%d) exceed maximum allowed (%d)",
				report.Summary.Medium, policy.MaxMedium))
		result.FailureCount++
	}

	// Check for unfixed vulnerabilities if required
	if policy.RequireFixAvailable {
		for _, vuln := range report.Vulnerabilities {
			if !vuln.FixAvailable && vuln.Severity.Score() >= SeverityMedium.Score() {
				result.Warnings = append(result.Warnings,
					fmt.Sprintf("No fix available for %s in package %s", vuln.ID, vuln.Package))
			}
		}
	}

	return result
}

// sortVulnerabilities sorts vulnerabilities by severity (critical first)
func (s *Scanner) sortVulnerabilities(vulns []Vulnerability) {
	sort.Slice(vulns, func(i, j int) bool {
		// First by severity (higher first)
		if vulns[i].Severity != vulns[j].Severity {
			return vulns[i].Severity.Score() > vulns[j].Severity.Score()
		}
		// Then by CVSS score (higher first)
		if vulns[i].CVSSScore != vulns[j].CVSSScore {
			return vulns[i].CVSSScore > vulns[j].CVSSScore
		}
		// Finally by ID
		return vulns[i].ID < vulns[j].ID
	})
}

// ExportJSON exports the report as JSON
func (r *Report) ExportJSON() ([]byte, error) {
	return json.MarshalIndent(r, "", "  ")
}

// ExportTable exports the report as a human-readable table
func (r *Report) ExportTable() string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("Vulnerability Scan Report for: %s\n", r.ImageRef))
	sb.WriteString(fmt.Sprintf("Scan Time: %s\n\n", r.ScanTime.Format(time.RFC3339)))

	sb.WriteString("SUMMARY:\n")
	sb.WriteString(strings.Repeat("-", 80) + "\n")
	sb.WriteString(fmt.Sprintf("Total Vulnerabilities: %d\n", r.Summary.TotalVulnerabilities))
	sb.WriteString(fmt.Sprintf("  Critical: %d\n", r.Summary.Critical))
	sb.WriteString(fmt.Sprintf("  High:     %d\n", r.Summary.High))
	sb.WriteString(fmt.Sprintf("  Medium:   %d\n", r.Summary.Medium))
	sb.WriteString(fmt.Sprintf("  Low:      %d\n", r.Summary.Low))
	sb.WriteString(fmt.Sprintf("\nTotal Packages: %d\n", r.Summary.TotalPackages))
	sb.WriteString(fmt.Sprintf("Vulnerable Packages: %d\n", r.Summary.VulnerablePackages))
	sb.WriteString(fmt.Sprintf("Packages with Fixes: %d\n\n", r.Summary.PackagesWithFixes))

	if len(r.Vulnerabilities) > 0 {
		sb.WriteString("VULNERABILITIES:\n")
		sb.WriteString(strings.Repeat("-", 80) + "\n")
		sb.WriteString(fmt.Sprintf("%-15s %-10s %-30s %-15s\n", "ID", "SEVERITY", "PACKAGE", "FIX VERSION"))
		sb.WriteString(strings.Repeat("-", 80) + "\n")

		for _, vuln := range r.Vulnerabilities {
			fixVersion := vuln.FixedInVersion
			if fixVersion == "" {
				fixVersion = "(no fix)"
			}
			sb.WriteString(fmt.Sprintf("%-15s %-10s %-30s %-15s\n",
				vuln.ID, vuln.Severity, vuln.Package, fixVersion))
		}
	}

	if r.PolicyResult != nil {
		sb.WriteString("\nPOLICY EVALUATION:\n")
		sb.WriteString(strings.Repeat("-", 80) + "\n")
		if r.PolicyResult.Passed {
			sb.WriteString("Status: PASSED\n")
		} else {
			sb.WriteString("Status: FAILED\n")
			sb.WriteString(fmt.Sprintf("Failures: %d\n\n", r.PolicyResult.FailureCount))
			for _, violation := range r.PolicyResult.Violations {
				sb.WriteString(fmt.Sprintf("  - %s\n", violation))
			}
		}
	}

	return sb.String()
}

// ExportSARIF exports the report in SARIF format (for GitHub integration)
func (r *Report) ExportSARIF() ([]byte, error) {
	sarif := map[string]interface{}{
		"version": "2.1.0",
		"$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
		"runs": []map[string]interface{}{
			{
				"tool": map[string]interface{}{
					"driver": map[string]interface{}{
						"name": r.ScannerName,
					},
				},
				"results": r.convertToSARIFResults(),
			},
		},
	}

	return json.MarshalIndent(sarif, "", "  ")
}

// convertToSARIFResults converts vulnerabilities to SARIF format
func (r *Report) convertToSARIFResults() []map[string]interface{} {
	results := []map[string]interface{}{}

	for _, vuln := range r.Vulnerabilities {
		results = append(results, map[string]interface{}{
			"ruleId": vuln.ID,
			"level":  r.severityToSARIFLevel(vuln.Severity),
			"message": map[string]interface{}{
				"text": fmt.Sprintf("%s in package %s %s", vuln.ID, vuln.Package, vuln.PackageVersion),
			},
			"locations": []map[string]interface{}{
				{
					"physicalLocation": map[string]interface{}{
						"artifactLocation": map[string]interface{}{
							"uri": r.ImageRef,
						},
					},
				},
			},
		})
	}

	return results
}

// severityToSARIFLevel converts severity to SARIF level
func (r *Report) severityToSARIFLevel(sev Severity) string {
	switch sev {
	case SeverityCritical, SeverityHigh:
		return "error"
	case SeverityMedium:
		return "warning"
	default:
		return "note"
	}
}
