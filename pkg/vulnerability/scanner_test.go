package vulnerability

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSeverityScore(t *testing.T) {
	tests := []struct {
		name     string
		severity Severity
		want     int
	}{
		{"critical", SeverityCritical, 5},
		{"high", SeverityHigh, 4},
		{"medium", SeverityMedium, 3},
		{"low", SeverityLow, 2},
		{"negligible", SeverityNegligible, 1},
		{"unknown", SeverityUnknown, 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.severity.Score()
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestNewScanner(t *testing.T) {
	// This would require a valid vulnerability database
	// Skipping for unit tests as it involves external dependencies
	t.Skip("Requires vulnerability database")
}

func TestCalculateSummary(t *testing.T) {
	vulns := []Vulnerability{
		{
			ID:           "CVE-2024-0001",
			Severity:     SeverityCritical,
			Package:      "openssl",
			FixAvailable: true,
		},
		{
			ID:           "CVE-2024-0002",
			Severity:     SeverityHigh,
			Package:      "curl",
			FixAvailable: true,
		},
		{
			ID:           "CVE-2024-0003",
			Severity:     SeverityMedium,
			Package:      "bash",
			FixAvailable: false,
		},
		{
			ID:           "CVE-2024-0004",
			Severity:     SeverityLow,
			Package:      "openssl",
			FixAvailable: false,
		},
	}

	scanner := &Scanner{}
	summary := scanner.calculateSummary(vulns, 10, 3)

	assert.Equal(t, 4, summary.TotalVulnerabilities)
	assert.Equal(t, 1, summary.Critical)
	assert.Equal(t, 1, summary.High)
	assert.Equal(t, 1, summary.Medium)
	assert.Equal(t, 1, summary.Low)
	assert.Equal(t, 10, summary.TotalPackages)
	assert.Equal(t, 3, summary.VulnerablePackages)
}

func TestEvaluatePolicy(t *testing.T) {
	tests := []struct {
		name           string
		policy         *ScanPolicy
		report         *Report
		wantPassed     bool
		wantViolations int
	}{
		{
			name: "pass - no violations",
			policy: &ScanPolicy{
				MaxCritical: 0,
				MaxHigh:     5,
				MaxMedium:   10,
			},
			report: &Report{
				Summary: Summary{
					Critical: 0,
					High:     3,
					Medium:   5,
				},
			},
			wantPassed:     true,
			wantViolations: 0,
		},
		{
			name: "fail - critical exceeded",
			policy: &ScanPolicy{
				MaxCritical: 0,
				MaxHigh:     5,
				MaxMedium:   10,
			},
			report: &Report{
				Summary: Summary{
					Critical: 2,
					High:     3,
					Medium:   5,
				},
			},
			wantPassed:     false,
			wantViolations: 1,
		},
		{
			name: "fail - multiple violations",
			policy: &ScanPolicy{
				MaxCritical: 0,
				MaxHigh:     2,
				MaxMedium:   3,
			},
			report: &Report{
				Summary: Summary{
					Critical: 1,
					High:     5,
					Medium:   8,
				},
			},
			wantPassed:     false,
			wantViolations: 3,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			scanner := &Scanner{
				config: ScanConfig{
					Policy: tt.policy,
				},
			}

			result := scanner.evaluatePolicy(tt.report)
			assert.Equal(t, tt.wantPassed, result.Passed)
			assert.Equal(t, tt.wantViolations, result.FailureCount)
		})
	}
}

func TestSortVulnerabilities(t *testing.T) {
	vulns := []Vulnerability{
		{ID: "CVE-3", Severity: SeverityLow, CVSSScore: 3.0},
		{ID: "CVE-1", Severity: SeverityCritical, CVSSScore: 9.8},
		{ID: "CVE-4", Severity: SeverityMedium, CVSSScore: 5.5},
		{ID: "CVE-2", Severity: SeverityHigh, CVSSScore: 7.5},
	}

	scanner := &Scanner{}
	scanner.sortVulnerabilities(vulns)

	// Should be sorted by severity (critical first)
	assert.Equal(t, SeverityCritical, vulns[0].Severity)
	assert.Equal(t, SeverityHigh, vulns[1].Severity)
	assert.Equal(t, SeverityMedium, vulns[2].Severity)
	assert.Equal(t, SeverityLow, vulns[3].Severity)
}

func TestReportExportJSON(t *testing.T) {
	report := &Report{
		ImageRef:    "nginx:latest",
		ScanTime:    time.Now(),
		ScannerName: "test-scanner",
		Vulnerabilities: []Vulnerability{
			{
				ID:       "CVE-2024-0001",
				Severity: SeverityCritical,
				Package:  "openssl",
			},
		},
		Summary: Summary{
			TotalVulnerabilities: 1,
			Critical:             1,
		},
	}

	data, err := report.ExportJSON()
	require.NoError(t, err)
	assert.NotEmpty(t, data)

	jsonStr := string(data)
	assert.Contains(t, jsonStr, "nginx:latest")
	assert.Contains(t, jsonStr, "CVE-2024-0001")
	assert.Contains(t, jsonStr, "openssl")
}

func TestReportExportTable(t *testing.T) {
	report := &Report{
		ImageRef:    "nginx:latest",
		ScanTime:    time.Now(),
		ScannerName: "test-scanner",
		Vulnerabilities: []Vulnerability{
			{
				ID:             "CVE-2024-0001",
				Severity:       SeverityCritical,
				Package:        "openssl",
				FixedInVersion: "1.1.1w",
			},
			{
				ID:             "CVE-2024-0002",
				Severity:       SeverityHigh,
				Package:        "curl",
				FixedInVersion: "8.5.0",
			},
		},
		Summary: Summary{
			TotalVulnerabilities: 2,
			Critical:             1,
			High:                 1,
			TotalPackages:        10,
			VulnerablePackages:   2,
		},
	}

	output := report.ExportTable()
	assert.Contains(t, output, "nginx:latest")
	assert.Contains(t, output, "SUMMARY:")
	assert.Contains(t, output, "Total Vulnerabilities: 2")
	assert.Contains(t, output, "Critical: 1")
	assert.Contains(t, output, "High:     1")
	assert.Contains(t, output, "VULNERABILITIES:")
	assert.Contains(t, output, "CVE-2024-0001")
	assert.Contains(t, output, "CVE-2024-0002")
	assert.Contains(t, output, "openssl")
	assert.Contains(t, output, "curl")
}

func TestReportExportSARIF(t *testing.T) {
	report := &Report{
		ImageRef:    "nginx:latest",
		ScannerName: "test-scanner",
		Vulnerabilities: []Vulnerability{
			{
				ID:       "CVE-2024-0001",
				Severity: SeverityCritical,
				Package:  "openssl",
			},
		},
	}

	data, err := report.ExportSARIF()
	require.NoError(t, err)
	assert.NotEmpty(t, data)

	sarifStr := string(data)
	assert.Contains(t, sarifStr, "2.1.0")
	assert.Contains(t, sarifStr, "test-scanner")
	assert.Contains(t, sarifStr, "CVE-2024-0001")
	assert.Contains(t, sarifStr, "error") // critical maps to error level
}

func TestSeverityToSARIFLevel(t *testing.T) {
	report := &Report{}

	tests := []struct {
		severity Severity
		want     string
	}{
		{SeverityCritical, "error"},
		{SeverityHigh, "error"},
		{SeverityMedium, "warning"},
		{SeverityLow, "note"},
		{SeverityNegligible, "note"},
	}

	for _, tt := range tests {
		t.Run(string(tt.severity), func(t *testing.T) {
			got := report.severityToSARIFLevel(tt.severity)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestVulnerability(t *testing.T) {
	vuln := Vulnerability{
		ID:             "CVE-2024-0001",
		Severity:       SeverityCritical,
		Package:        "openssl",
		PackageVersion: "1.1.1k",
		PackageType:    "deb",
		FixedInVersion: "1.1.1w",
		FixAvailable:   true,
		Title:          "OpenSSL vulnerability",
		Description:    "A critical vulnerability in OpenSSL",
		URLs:           []string{"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-0001"},
		CVSSScore:      9.8,
		CVSSVector:     "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
		DataSource:     "nvd",
	}

	assert.Equal(t, "CVE-2024-0001", vuln.ID)
	assert.Equal(t, SeverityCritical, vuln.Severity)
	assert.True(t, vuln.FixAvailable)
	assert.Equal(t, 9.8, vuln.CVSSScore)
	assert.NotEmpty(t, vuln.URLs)
}

func TestPolicyRule(t *testing.T) {
	rule := PolicyRule{
		Name:        "block-gpl",
		Severity:    SeverityHigh,
		Action:      "deny",
		Conditions:  []string{"license contains 'GPL'"},
		Description: "Block GPL licenses",
	}

	assert.Equal(t, "block-gpl", rule.Name)
	assert.Equal(t, SeverityHigh, rule.Severity)
	assert.Equal(t, "deny", rule.Action)
	assert.Contains(t, rule.Conditions, "license contains 'GPL'")
}

func TestPolicyResult(t *testing.T) {
	result := PolicyResult{
		Passed:       false,
		FailureCount: 2,
		Violations: []string{
			"Critical vulnerabilities exceed maximum",
			"High vulnerabilities exceed maximum",
		},
		Warnings: []string{
			"No fix available for CVE-2024-0001",
		},
	}

	assert.False(t, result.Passed)
	assert.Equal(t, 2, result.FailureCount)
	assert.Len(t, result.Violations, 2)
	assert.Len(t, result.Warnings, 1)
}

func TestSummaryStatistics(t *testing.T) {
	summary := Summary{
		TotalVulnerabilities: 15,
		Critical:             2,
		High:                 5,
		Medium:               6,
		Low:                  2,
		TotalPackages:        100,
		VulnerablePackages:   10,
		PackagesWithFixes:    8,
		PackagesWithoutFixes: 2,
	}

	assert.Equal(t, 15, summary.TotalVulnerabilities)
	assert.Equal(t, 2, summary.Critical)
	assert.Equal(t, 5, summary.High)
	assert.Equal(t, 100, summary.TotalPackages)
	assert.Equal(t, 10, summary.VulnerablePackages)
}

func TestVulnerabilityMetadata(t *testing.T) {
	vuln := Vulnerability{
		ID:       "CVE-2024-0001",
		Severity: SeverityCritical,
		Metadata: map[string]string{
			"source":   "nvd",
			"language": "C",
			"cpe":      "cpe:2.3:a:openssl:openssl:1.1.1k:*:*:*:*:*:*:*",
		},
	}

	assert.Equal(t, "nvd", vuln.Metadata["source"])
	assert.Equal(t, "C", vuln.Metadata["language"])
	assert.Contains(t, vuln.Metadata["cpe"], "openssl")
}

func TestCVSSMetrics(t *testing.T) {
	vuln := Vulnerability{
		CVSSScore:  9.8,
		CVSSVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
		CVSSMetrics: map[string]float64{
			"base":           9.8,
			"exploitability": 3.9,
			"impact":         5.9,
		},
	}

	assert.Equal(t, 9.8, vuln.CVSSScore)
	assert.NotEmpty(t, vuln.CVSSVector)
	assert.Equal(t, 9.8, vuln.CVSSMetrics["base"])
	assert.Equal(t, 3.9, vuln.CVSSMetrics["exploitability"])
	assert.Equal(t, 5.9, vuln.CVSSMetrics["impact"])
}

func TestVulnerabilityDates(t *testing.T) {
	published := time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)
	modified := time.Date(2024, 1, 20, 0, 0, 0, 0, time.UTC)

	vuln := Vulnerability{
		ID:            "CVE-2024-0001",
		PublishedDate: published,
		ModifiedDate:  modified,
	}

	assert.Equal(t, published, vuln.PublishedDate)
	assert.Equal(t, modified, vuln.ModifiedDate)
	assert.True(t, vuln.ModifiedDate.After(vuln.PublishedDate))
}

func TestFixInformation(t *testing.T) {
	tests := []struct {
		name string
		vuln Vulnerability
		want bool
	}{
		{
			name: "fix available",
			vuln: Vulnerability{
				FixAvailable:   true,
				FixedInVersion: "1.1.1w",
				FixedVersions:  []string{"1.1.1w", "1.2.0"},
			},
			want: true,
		},
		{
			name: "no fix available",
			vuln: Vulnerability{
				FixAvailable: false,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, tt.vuln.FixAvailable)
		})
	}
}

func TestScanConfig(t *testing.T) {
	config := ScanConfig{
		FailOnSeverity: SeverityHigh,
		IgnoreUnfixed:  true,
		OnlyFixed:      false,
		AutoUpdateDB:   true,
		OutputFormat:   "json",
		Verbose:        true,
	}

	assert.Equal(t, SeverityHigh, config.FailOnSeverity)
	assert.True(t, config.IgnoreUnfixed)
	assert.False(t, config.OnlyFixed)
	assert.True(t, config.AutoUpdateDB)
}

func TestNewVulnerabilityDB(t *testing.T) {
	db, err := NewVulnerabilityDB("/tmp/test-vuln-db")
	require.NoError(t, err)
	assert.NotNil(t, db)
	assert.Contains(t, db.path, "test-vuln-db")
}

func TestVulnerabilityDBDefaultPath(t *testing.T) {
	db, err := NewVulnerabilityDB("")
	require.NoError(t, err)
	assert.NotNil(t, db)
	assert.Contains(t, db.path, ".cache/freightliner/vulnerability-db")
}
